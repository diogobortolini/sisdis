<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Trabalho Prático 1 - Diogo Bortolini</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.css" rel="stylesheet">
    
    <!-- Custom CSS for the '3 Col Portfolio' Template -->
    <link href="css/portfolio-item.css" rel="stylesheet">
  </head>

  <body>

    <nav class="navbar navbar-fixed-top navbar-inverse" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="https://diogobortolini.github.io/sisdis/">Diogo Bortolini - Sistemas Distribuídos</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
          <ul class="nav navbar-nav">
            <li><a href="t0.html">Trabalho 0</a></li>
            <li><a href="t1.html">Trabalho 1</a></li>
             <li><a href="#img0">Uso</a></li>
            <li><a href="#img1">Testes</a></li>
             <li><a href="#img2">Estruturas</a></li>
             <li><a href="#img3">Registros</a></li>
            <li><a href="#img4">Infos</a></li>
          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container -->
    </nav>

    <div class="container">

      <div class="row">

        <div class="col-lg-12">
          <h1 class="page-header">Trabalho Prático 1 -  <small>Roteiro de Aprendizado Prático de Simulação de um algoritmo vCube</small></h1>
        </div>

      </div>

      <div class="row">

        <div class="col-md-4">
          <img class="img-responsive" src="images/Figura-1-Topologia-do-VCube-com-tres-dimensoes-e-clusters-do-processo-0.png">
        </div>

        <div class="col-md-8">
          <h3>Descrição do Trabalho 1 - Relatório da Implementação</h3>
          <p class="text-justify">Implementação de um detector de falhas vCube no ambiente de simulação SMPL, exibindo os resultados para diversos valores de N e diversos eventos. Um evento consiste da mudança de estado de um ou mais processos. Para cada evento é exibido o número de testes executados e a latência para todos os processos corretos detectarem o evento. Cada processo mantém o vetor STATE[0..N-1] de contadores de eventos, inicializado em -1 (estado “unknown”). Assume-se que os processos são inicializados corretos (estado 0), a entrada correspondente ao próprio processo no vetor STATE[] do testador é setada para zero. Ao descobrir um novo evento em um nodo testado, o testador incrementa a entrada correspondente no vetor STATE[].</p>
          <!--<h3>Project Details</h3>
          <ul>
            <li>Lorem Ipsum</li>
            <li>Dolor Sit Amet</li>
            <li>Consectetur</li>
            <li>Adipiscing Elit</li>
          </ul>-->
        </div>     
        
      </div>   
      <div class="row">
      <div class="col-lg-12">
          <a name="img0"></a>
          <h3 class="page-header">Compilação e Uso</h3>
        </div>
        <div class="col-md-12">
          <p><strong>Descrição do Uso </strong></p>
          <p class="text-justify">Entre os arquivos existentes nes trabalho estão smpl.h (que contém o cabeçalho da biblioteca SMPL), smpl.c (próprio código fonte da biblioteca SMPL), rand.c (funções complementares da SMPL), o cisj.c	(que possuía o código fonte fornecido pelo professor para calculo da cisj e foi utilizado para o main do programa), além do makefile (que organiza e compila o programa)

          <p><strong>Arquivos de Tarefas</strong></p>
          <ul>
            <li><a href = "files/smpl.h.txt" target= "_blank">smpl.h</a></li>
            <li><a href = "files/smpl.c.txt" target= "_blank">smpl.c</a></li>
            <li><a href = "files/rand.c.txt" target= "_blank">rand.c</a></li>
            <li><a href = "files/cisj.c.txt" target= "_blank">cisj.c</a></li>
            <li><a href = "files/makefile.txt" target= "_blank">makefile</a></li>
          </ul>
          <p class="text-justify">Colocar os arquivos acima em um mesmo diretório e compilar com os comandos <code>make purge && make</code> (make purge irá excluir os arquivos atuais e make irá compilar. <br>
           Ocorrendo a compilação sem erros, basta executar o comando <strong>./cisj &#60;num_processos&#62; &#60;tempo_simulacao&#62;</strong>, por exemplo, <code>./cisj 8 300</code> para criar uma simulação com 8 processos e por 300ms.</div>

      </div>
      
      <div class="row">
      <div class="col-lg-12">
           <a name="img1"></a>
          <h3 class="page-header">Testes</h3>
        </div>
           <p class="text-justify">Diferentes testes foram realizados com números de processos distintos e diversos escalonamentos de eventos, em vários tempos de simulação.

          <p><strong>Arquivos de Tarefas</strong></p>
          <p class="text-justify">Testes com 100 unidades de tempo de simulação, sem processos falhos e testados com 2, 4, 8, 16 processos, respectivamente </p>
          <ul>
            <li><a href = "files/log2.sf.txt" target= "_blank">log2.sf.txt</a></li>
            <li><a href = "files/log4.sf.txt" target= "_blank">log4.sf.txt</a></li>
            <li><a href = "files/log8.sf.txt" target= "_blank">log8.sf.txt</a></li>
            <li><a href = "files/log16.sf.txt" target= "_blank">log16.sf.txt</a></li>
          </ul><br>
          <p class="text-justify">Testes com 500 unidades de tempo de simulação, com processos 1,3,5,7 falhos nos tempos 100,100, 160, 300 respectivamente. 
            Os processos 1,3,5,7 são recuperados nos tempos 210,400,300,400, respectivamente. Esse mesmo teste foi feito com 8 e 16 processos.</p>
          <ul>
            <li><a href = "files/log8.cf.txt" target= "_blank">log8.cf.txt</a></li>
            <li><a href = "files/log16.cf.txt" target= "_blank">log16.cf.txt</a></li>
          </ul><br>


      </div>
      
            <div class="row">
      <div class="col-lg-12">
          <a name="img2"></a>
          <h3 class="page-header">Estruturas, Funções e Variáveis Globais</h3>
        </div>
        <div class="col-md-8">
          <a href="images/struct.jpg"><img class="img-responsive" src="images/struct.jpg"></a><br>
          <a href="images/function.jpg"><img class="img-responsive" src="images/function.jpg"></a>
        </div>

        <div class="col-md-4">
          <p><strong>Apresentação das Estruturas, Funções e Variáveis Globais</strong></p>
          <p class="text-justify">O algoritmo possui algumas estruturas que foram implementadas de forma manter informações do nós e seus eventos. 
           A primeira estrutura é <strong>node_set</strong> que já foi disponibilizada pelo professor e tem por objetivo de de gerar o conjunto de nós, junto as funções 
            <strong>set_new</strong>, <strong>set_insert</strong>, <strong>set_merge</strong> e <strong>set_free</strong>, 
            sendo que as funções são utilizadas para criar, inserir, mesclar e limpar o conjunto de processos, respectivamente. São utilizadas principalmente na função <strong>cis</strong> que retorna a lista de processos (em
ordem) que devem ser testados pelo testador i nos clusters s=1,2,…,logN (onde N é o número de processos).
            Depois temos a estrutura <strong>st_cis</strong> que armazena a tabela dos clusters com base na estrutura mencionada anteriormente. Tal tabela é calculada pela função <strong>CriaCis</strong> e, portanto, uma vez criado o conjunto de nós e seus clusters é criado a matriz com os testes a serem executados através da função <strong>matrizTeste</strong>.
            Na sequância foi criada a estrutura <strong>st_no</strong> que possui informações do respectivo id do processo e os estados dos demais processos que tal id tem conhecimento.
            Por fim, a estrutura <strong>st_event</strong> que armazena as informações de evento de determinado processo, com isso é possível saber qual o tipo de evento que tal processo sofreu (FAULT ou RECOVERY), qual rodada de testes estava ocorrendo quando o evento aconteceu, e demais informações como latência, número do teste e a situação atual do evento.
            Entre as váriaveis globais temos <strong>st_no</strong> onde estão os processos (nós), o número de clusters (conforme a qunatidade de processos), uma várivel de controle chamad <strong>printar</strong> para saber quando imprimir os States dos processos (no caso, ele imprime apenas quando ocorre efetivamente alguma alterações do States do processo testando) e um ponteiro para inteiro (<strong>info_no</strong>) com resultados dos processos Corretos e falhos e ativos e, o número de processos (<strong>n</strong>).</p>
        </div>

      </div>
      
            <div class="row">
      <div class="col-lg-12">
           <a name="img3"></a>
          <h3 class="page-header">Registro dos Eventos e States</h3>
        </div>
        <div class="col-md-8">
          <a href="images/events.jpg"><img class="img-responsive" src="images/events.jpg"></a><br>
          <a href="images/states.jpg"><img class="img-responsive" src="images/states.jpg"></a>
        </div>

        <div class="col-md-4">
          <p><strong>Funções para marcação dos Eventos</strong></p>
          <p class="text-justify">Com o objetivo de verificar os eventos ocorridos nos processos (FAULT ou RECOVERY) e anotar a latência gasta alguns funções foram criadas. A função <strong>novoEvento</strong>, consiste em setar valores da estrutura do evento, com o tipo do evento, zera o contador de latência, anota a rodada que o evento ocorreu, zer o número de testes e o contado de testes atual. A função <strong>novoEvento</strong> é chamado sempre que um evento de FAULT ou RECOVERY ocorre e a função <strong>imprimirEvento</strong> é executada para imprimir na tela as informações do evento.
            Outra função é a de <strong>limpaEvento</strong> que limpa a estrutura dos eventos, setando os valores para -1 (unknown). Essa função é chamada sempre que um evento foi percebido e atualizado por todos os processos corretos. A cada teste executado a função <strong>atualizaEvento</strong> é chamada para verificar se todos os processos estão com o status do evento atualizados, se estiverem a função <strong>imprimirEvento</strong> é executada para imprimir na tela as informações do evento percebido.</p>
          <p><strong>Funções para marcação dos States</strong></p>
          <p class="text-justify">Outro fator importante é as função que controlam o States de cada processo, que nada mais é do que o registro do estado de todos os processos que tal processo sabe. Logo no início do programa, a função <strong>limpaState</strong> que é responsável por iniciar o States (array) de cada processo com o valor -1 (unknown), exceto o valor do estado que representa o próprio processo (setando para 0, ou seja correto), obviamente que o próprio processo correto, sabe que o seu estado é correto.
           Sempre que um processo correto executa um teste em um processo correto (OK), então ele verifica o State do processo testado e verifica se há alguma informações que esteja atualizada em relação ao seu State. Sempre que um processo detecta que ocorreu um novo evento, o estado daquele processo é incrementado no State, ou seja, os processo no State são setados como -1 (unknown), quando ocorre um teste correto, o valor é incrementado (+1), ficando 0. Se tal processo em algum momento falhar, o estado é incrementado, ficando 1. Se posteriormente se recuperar, se estado será 2 e, assim sucessivamente. Percebe-se que valores ímpares indicam que o processo está com FAULT (falho) e números pares está Correto (ok). A função que verifica se precisa atualizar o States é a função <strong>atualizaState</strong> que verifica se algum valor de State do processo testado é maior que o do testado, se for ele atualiza. Por fim, a função <strong>imprimirState</strong> mostra o State de todos os processos. No caso deste programa, o State é invocado apenas quando detecta que houve alguma mundança no State de pelo menos um processo (para não possui muito os logs).   
         </div>

      </div>
      
      <div class="row">
      <div class="col-lg-12">
           <a name="img4"></a>
          <h3 class="page-header">Outras Informações</h3>
        </div>
        <div class="col-md-8">
          <a href="images/outros.jpg"><img class="img-responsive" src="images/outros.jpg"></a><br />
        </div>

        <div class="col-md-4">
          <p><strong>Demais informações</strong></p>
          <p class="text-justify">Por fim, os testes são realizados a cada 30 unidades de tempo conforme a matrizTeste gerada com os testes a serem realizados. Na função <strong>main</strong> estão os eventos escalonados de FAULT e RECOVERY. Um loop com os testes é realizado enquanto o tempo na simulação não se esgotar (argumento informado no momento da execução).</p>
        </div>

      </div>
    </div><!-- /.container -->

    <div class="container">

      <hr>

      <footer>
        <div class="row">
          <div class="col-lg-12">
            <p>Copyright &copy; 2023</p>
          </div>
        </div>
      </footer>
      
    </div><!-- /.container -->

    <script src="js/jquery-1.10.2.js"></script>
    <script src="js/bootstrap.js"></script>
    <script src="js/my.js"></script>

  </body>

</html>
