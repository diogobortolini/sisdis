<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Trabalho Prático 2 - Diogo Bortolini</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.css" rel="stylesheet">
    
    <!-- Custom CSS for the '3 Col Portfolio' Template -->
    <link href="css/portfolio-item.css" rel="stylesheet">
  </head>

  <body>

    <nav class="navbar navbar-fixed-top navbar-inverse" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="https://diogobortolini.github.io/sisdis/">Diogo Bortolini - Sistemas Distribuídos</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
          <ul class="nav navbar-nav">
            <li><a href="t0.html">Trabalho 0</a></li>
            <li><a href="t1.html">Trabalho 1</a></li>
             <li><a href="t2.html">Trabalho 2</a></li>
          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container -->
    </nav>

    <div class="container">

      <div class="row">

        <div class="col-lg-12">
          <h1 class="page-header">Trabalho Prático 2 -  <small>Roteiro de Aprendizado Prático de Simulação de um algoritmo vCube Assíncrono</small></h1>
        </div>

      </div>

      <div class="row">

        <div class="col-md-4">
          <img class="img-responsive" src="images/assync.jpg">
        </div>

        <div class="col-md-8">
          <h3>Descrição do Trabalho 2 - Relatório da Implementação</h3>
          <p class="text-justify">Implementação de um vCube para o modelo assíncrono no ambiente de simulação SMPL. Todo detector de falhas em um sistema assíncrono pode cometer falsas suspeitas, isto é: suspeitar que um processo correto está falho. No caso do vCube, a cada teste de processo correto, o testador determina com base em uma probabilidade (1%, 10%, 30%, 50%, entre outros valores possíveis e configuráveis) que o teste será uma falsa suspeita. No vCube para sistemas assíncronos, assim que o processo obtém a informação de que foi vítima de uma falsa suspeita, o processo encerra a execução e sai do sistema, para simular basta fazer com o processo falhe definitivamente. Diversos casos de execução são exibidos, destacando as configurações resultantes e o número de rodadas entre uma falsa suspeita e a saída do processo do sistema.</p>
          <!--<h3>Project Details</h3>
          <ul>
            <li>Lorem Ipsum</li>
            <li>Dolor Sit Amet</li>
            <li>Consectetur</li>
            <li>Adipiscing Elit</li>
          </ul>-->
        </div>     
        
      </div>   
      <div class="row">
      <div class="col-lg-12">
          <a name="img0"></a>
          <h3 class="page-header">Compilação e Uso</h3>
        </div>
        <div class="col-md-12">
          <p><strong>Descrição do Uso </strong></p>
          <p class="text-justify">Entre os arquivos existentes nes trabalho estão smpl.h (que contém o cabeçalho da biblioteca SMPL), smpl.c (próprio código fonte da biblioteca SMPL), rand.c (funções complementares da SMPL), o cisjAssinc.c	(que possuía o código fonte fornecido pelo professor para calculo da cisj e foi utilizado para o main do programa), além do makefile (que organiza e compila o programa)

          <p><strong>Arquivos de Tarefas</strong></p>
          <ul>
            <li><a href = "files/t2/smpl.h.txt" target= "_blank">smpl.h</a></li>
            <li><a href = "files/t2/smpl.c.txt" target= "_blank">smpl.c</a></li>
            <li><a href = "files/t2/rand.c.txt" target= "_blank">rand.c</a></li>
            <li><a href = "files/t2/cisjAssinc.c.txt" target= "_blank">cisjAssinc.c</a></li>
            <li><a href = "files/t2/makefile.txt" target= "_blank">makefile</a></li>
          </ul>
          <p class="text-justify">Colocar os arquivos acima em um mesmo diretório e compilar com os comandos <code>make purge && make</code> (make purge irá excluir os arquivos atuais e make irá compilar. <br>
           Ocorrendo a compilação sem erros, basta executar o comando <strong>./cisjAssinc &#60;num_processos&#62; &#60;tempo_simulacao&#62; &#60;probabilidade de falsa suspeita em %&#62;</strong>, por exemplo, <code>./cisjAssinc 8 300 10</code> para criar uma simulação com 8 processos e por 300ms com uma probabilidade de falsa suspeita de 10&#37;. Lembrando que no código acima não existe nenhuma falha programada. Todas as falhas surgem de um falsa suspeita e quando o processo descobre que foi vítima de uma falsa suspeita, o processo encerra a execução e sai do sistema, falhando verdadeiramente e definitivamente.</div>

      </div>
      
      <div class="row">
      <div class="col-lg-12">
           <a name="img1"></a>
          <h3 class="page-header">Testes</h3>
        </div>
           <p class="text-justify">Diferentes testes foram realizados com números de processos com diferentes probabilidades de falsas suspeitas e tempos de execução

          <p><strong>Arquivos de Logs</strong></p>
          <p class="text-justify">Testes com diferentes unidades de tempo de simulação, sem processos falhos e testados com 8 processos e diferentes probabilidades de falsas suspeitas. Abaixo a descrição do resultado dos testes</p>
          <ul>
            <li><a href = "files/t2/t2log_8_1000_0.txt" target= "_blank">t2log_8_1000_0.txt</a></li>
            <li><a href = "files/t2/t2log_8_800_1.txt" target= "_blank">t2log_8_800_1.txt</a></li>
            <li><a href = "files/t2/t2log_8_800_10.txt" target= "_blank">t2log_8_800_10.txt</a></li>
            <li><a href = "files/t2/t2log_8_600_30.txt" target= "_blank">t2log_8_600_30.txt</a></li>
          </ul><br>
          <br>
      </div>

      <div class="row">
      <div class="col-lg-12">
          <a name="testes"></a>
          <h3 class="page-header">Testes e Resultados</h3>
        </div>
        <div class="col-md-12">
          <p><strong>Teste com 8 processos, 1000 unidades de tempo e 0% de probabilidade de falha: <a href = "files/t2/t2log_8_1000_0.txt" target= "_blank">t2log_8_1000_0.txt</a></strong></p>
          <p class="text-justify">Conforme esperado, em uma simulação onde nenhum processo falha e nenhum falsa suspeita é levantada (probabilidade de 0%. Isso indica uma forte precisão (Perfeito P), uma vez que nenhum processo correto é suspeitado.</p>
          <p><strong>Teste com 8 processos, 800 unidades de tempo e 1% de probabilidade de falha: <a href = "files/t2/t2log_8_800_1.txt" target= "_blank">t2log_8_800_1.txt</a></strong></p>
          <p class="text-justify">Neste caso apenas 1% dos testes levantam uma falsa suspeita. O processo descobre que foi vítima de uma falsa suspeita na mesma rodada ou em até uma (1) rodada (dependendo do cluster de teste) após ser suspeitada. Como as falsas suspeitas são raras, normalmente, a vítima vai descobrir quando for atualizar os status com base nas informações do processo de levantou a falsa suspeita ou de algum processo do cluster mais próximo. Perceba o caso da rodada 25, onde o processo 0 suspeita de falha o processo 1 e este, por sua vez, logo na sequência, ao testar o processo 0 detecta que foi vítima de falsa suspeita e deixa o sistema (falha). Ao final estão falhos os processos 1,3,5 e 6.</p>
          <p><strong>Teste com 8 processos, 800 unidades de tempo e 10% de probabilidade de falha: <a href = "files/t2/t2log_8_800_10.txt" target= "_blank">t2log_8_800_10.txt</a></strong></p>
          <p class="text-justify">Neste caso apenas 10% dos testes levantam uma falsa suspeita. Algumas coisas interessantes ocorrem já neste nível de possíveis falhas, por exemplo, a latência para um processo descobrir que foi vítima de uma falsa suspeita pode ser maior devido ao número de falsas suspeitas. Por exemplo, na rodada 3 quando o processo 7 testa e levanta uma falsa suspeita de 5. O processo 5 testa o processo 7 na rodada 4 e suspeita ele de falha, logo não descobre que anteriormente o próprio processo 7 tenha suspeitado dele. O processo 5 vai descobrir que foi vítima de falsa suspeita somente quando testa o processo 6 e fica sabendo por ele, isso na rodada 5 (ou seja, latência de duas rodadas). Outro fato interessante é que, com tal probabilidade de falhas, na rodada 7 estão corretos apenas os processos 0, 1 e 6. Quando o processo 6 testa com 1 com falsa suspeita. Na rodada 8 o processo 0 testa o 6 com falsa suspeita e não fica sabendo da condição do processo 1. Na rodada 9 os processos 0 e 1 se testam com resultado OK. Na rodada 10 que o processo 0 vai levanta falsa suspeita de 1 e, este por sua vez, ao testar correto o 0 detecta que foi vítima de falsa suspeita. Para fins didáticos, mantemos a latência deste evento do process 1 como sendo 3 (considerando a primeira vez que houve a suspeita pelo teste do processo 6 na rodada 7), embora possa ser contestável.</p>
          <p><strong>Teste com 8 processos, 600 unidades de tempo e 30% de probabilidade de falha: <a href = "files/t2/t2log_8_600_30.txt" target= "_blank">t2log_8_600_30.txt</a></strong></p>
          <p class="text-justify">Com 30% dos testes levantando falsa suspeita, ao final da rodada 3, o processo 6 para de executar testes pois ele acredita que apenas ele está correto, embora ainda estejam ativos os processos 2 e 3, ou seja, o processo 6 testou com falsa falha os processos restantes 2 e 3. Na rodada 5, o processo 3 testa com falha o processo 2 e para de testar, pois acredita estar sozinho (o processo 6 já tinha sido reconhecido como falho, erroneamente, quando atualizou a informação do processo 2). Por fim, na rodada 6, o processo 2 testa o processo 3 com falsa suspeita e também para de testar. Com isso, os processos 2, 3 e 6 estão isolados.</p>
      </div>
            <div class="row">
      <div class="col-lg-12">
          <a name="img2"></a>
          <h3 class="page-header">Modificações e Alterações</h3>
        </div>
        <div class="col-md-8">
          <a href="images/compare.jpg"><img class="img-responsive" src="images/compare.jpg"></a><br>
        </div>

        <div class="col-md-4">
          <p><strong>Modificações em Relação ao <a href = "t1.html" target= "_blank">Trabalho P1</a></strong></p>
          <p class="text-justify">O algoritmo foi construído com base no <a href = "t1.html" target= "_blank">Trabalho P1</a>, entretanto, entre as modificações, agora os processos podem ser
           podem ser tratados como suspeitos de falha. Portanto a primeiro modificação consiste em um novo evento chamado <i>SUSPECT</i> (Suspeito), além dos estados <i>TEST</i> (Teste), <i>FAULT</i> (Falha) e <i>RECOVERY</i> (Recuperação), sendo que este último foi mantido no algoritmo, mas não há possibilidade do processo sofrer um recuperação neste modelo.</p>
          <p class="text-justify">A execução do algoritmo ocorre pela chamada da função <strong>cisjAssinc</strong> e além dos arquivos anteriores - num de processos e tempo de simulação - este novo algoritmo espera receber também a probabilidade de falhas nos testes do processos, sendo um número entre 0 e 100, onde 0 significa que há 0% chances de um teste levantar uma falsa suspeita de falha de um processo e, portanto, 100 significa, sempre suspeitar uma falha. A cada teste um número entre 0 e 100 é escolhido aleatoriamente (na verdade de forma pseudoaleatória). Se o número escolhido for menor ou igual ao valor da probabilidade informada, o teste de um processo válido levantará falsa suspeita de falha.
            Quando um processo está OK e é levantada uma falsa suspeita, tal informação aparece na tela e um evento para o processo vítima é criado. Dessa forma. o evento serve para contar quantas rodadas e testes se passaram, até que o processo perceba que ele foi vítima de uma falsa suspeita e provoque um auto encerramento (processo sai do sistema e passa a ser efetivamente uma falha real).
            Por fim, um processo só vai detectar que foi vítima de uma falsa suspeita quando ele testar corretamente um processo válido e ao atualizar os estados dos processos com base nas informações do processo testado, ele verificar se o seu estado naquele processo está como falho. Então ele sai do sistema e se torna uma falha real.</p>
        </div>

      </div>
    </div><!-- /.container -->

    <div class="container">

      <hr>

      <footer>
        <div class="row">
          <div class="col-lg-12">
            <p>Copyright &copy; 2023</p>
          </div>
        </div>
      </footer>
      
    </div><!-- /.container -->

    <script src="js/jquery-1.10.2.js"></script>
    <script src="js/bootstrap.js"></script>
    <script src="js/my.js"></script>

  </body>

</html>
