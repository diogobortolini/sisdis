<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Trabalho Prático 2 - Diogo Bortolini</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.css" rel="stylesheet">
    
    <!-- Custom CSS for the '3 Col Portfolio' Template -->
    <link href="css/portfolio-item.css" rel="stylesheet">
  </head>

  <body>

    <nav class="navbar navbar-fixed-top navbar-inverse" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="https://diogobortolini.github.io/sisdis/">Diogo Bortolini - Sistemas Distribuídos</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
          <ul class="nav navbar-nav">
            <li><a href="t0.html">Trabalho 0</a></li>
            <li><a href="t1.html">Trabalho 1</a></li>
             <li><a href="t2.html">Trabalho 2</a></li>
             <li><a href="#img0">Uso</a></li>
            <li><a href="#img1">Testes</a></li>
             <li><a href="#img2">Estruturas</a></li>
             <li><a href="#img3">Registros</a></li>
            <li><a href="#img4">Infos</a></li>
          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container -->
    </nav>

    <div class="container">

      <div class="row">

        <div class="col-lg-12">
          <h1 class="page-header">Trabalho Prático 2 -  <small>Roteiro de Aprendizado Prático de Simulação de um algoritmo vCube Assíncrono</small></h1>
        </div>

      </div>

      <div class="row">

        <div class="col-md-4">
          <img class="img-responsive" src="images/Figura-1-Topologia-do-VCube-com-tres-dimensoes-e-clusters-do-processo-0.png">
        </div>

        <div class="col-md-8">
          <h3>Descrição do Trabalho 2 - Relatório da Implementação</h3>
          <p class="text-justify">Implementação de um vCube para o modelo assíncrono no ambiente de simulação SMPL. Todo detector de falhas em um sistema assíncrono pode cometer falsas suspeitas, isto é: suspeitar que um processo correto está falho. No caso do vCube, a cada teste de processo correto, o testador determina com base em uma probabilidade (1%, 10%, 30%, 50%, entre outros valores possíveis e configuráveis) que o teste será uma falsa suspeita. No vCube para sistemas assíncronos, assim que o processo obtém a informação de que foi vítima de uma falsa suspeita, o processo encerra a execução e sai do sistema, para simular basta fazer com o processo falhe definitivamente. Diversos casos de execução são exibidos, destacando as configurações resultantes e o número de rodadas entre uma falsa suspeita e a saída do processo do sistema.</p>
          <!--<h3>Project Details</h3>
          <ul>
            <li>Lorem Ipsum</li>
            <li>Dolor Sit Amet</li>
            <li>Consectetur</li>
            <li>Adipiscing Elit</li>
          </ul>-->
        </div>     
        
      </div>   
      <div class="row">
      <div class="col-lg-12">
          <a name="img0"></a>
          <h3 class="page-header">Compilação e Uso</h3>
        </div>
        <div class="col-md-12">
          <p><strong>Descrição do Uso </strong></p>
          <p class="text-justify">Entre os arquivos existentes nes trabalho estão smpl.h (que contém o cabeçalho da biblioteca SMPL), smpl.c (próprio código fonte da biblioteca SMPL), rand.c (funções complementares da SMPL), o cisjAssinc.c	(que possuía o código fonte fornecido pelo professor para calculo da cisj e foi utilizado para o main do programa), além do makefile (que organiza e compila o programa)

          <p><strong>Arquivos de Tarefas</strong></p>
          <ul>
            <li><a href = "files/t2/smpl.h.txt" target= "_blank">smpl.h</a></li>
            <li><a href = "files/t2/smpl.c.txt" target= "_blank">smpl.c</a></li>
            <li><a href = "files/t2/rand.c.txt" target= "_blank">rand.c</a></li>
            <li><a href = "files/t2/cisjAssinc.c.txt" target= "_blank">cisjAssinc.c</a></li>
            <li><a href = "files/makefile.txt" target= "_blank">makefile</a></li>
          </ul>
          <p class="text-justify">Colocar os arquivos acima em um mesmo diretório e compilar com os comandos <code>make purge && make</code> (make purge irá excluir os arquivos atuais e make irá compilar. <br>
           Ocorrendo a compilação sem erros, basta executar o comando <strong>./cisjAssinc &#60;num_processos&#62; &#60;tempo_simulacao&#62; &#60;probabilidade de falsa suspeita em %&#62;</strong>, por exemplo, <code>./cisjAssinc 8 300 10</code> para criar uma simulação com 8 processos e por 300ms com uma probabilidade de falsa suspeita de 10&#37;. Lembrando que no código acima não existe nenhuma falha programada. Todas as falhas surgem de um falsa suspeita e quando o processo descobre que foi vítima de uma falsa suspeita, o processo encerra a execução e sai do sistema, falhando verdadeiramente e definitivamente.</div>

      </div>
      
      <div class="row">
      <div class="col-lg-12">
           <a name="img1"></a>
          <h3 class="page-header">Testes</h3>
        </div>
           <p class="text-justify">Diferentes testes foram realizados com números de processos com diferentes probabilidades de falsas suspeitas e tempos de execução

          <p><strong>Arquivos de Tarefas</strong></p>
          <p class="text-justify">Testes com 100 unidades de tempo de simulação, sem processos falhos e testados com 2, 4, 8, 16 processos, respectivamente </p>
          <ul>
            <li><a href = "files/log2.sf.txt" target= "_blank">log2.sf.txt</a></li>
            <li><a href = "files/log4.sf.txt" target= "_blank">log4.sf.txt</a></li>
            <li><a href = "files/log8.sf.txt" target= "_blank">log8.sf.txt</a></li>
            <li><a href = "files/log16.sf.txt" target= "_blank">log16.sf.txt</a></li>
          </ul><br>
          <p class="text-justify">Testes com 500 unidades de tempo de simulação, com processos 1,3,5,7 falhos nos tempos 100,100, 160, 300 respectivamente. 
            Os processos 1,3,5,7 são recuperados nos tempos 210,400,300,400, respectivamente. Esse mesmo teste foi feito com 8 e 16 processos.</p>
          <ul>
            <li><a href = "files/log8.cf.txt" target= "_blank">log8.cf.txt</a></li>
            <li><a href = "files/log16.cf.txt" target= "_blank">log16.cf.txt</a></li>
          </ul><br>


      </div>
      
            <div class="row">
      <div class="col-lg-12">
          <a name="img2"></a>
          <h3 class="page-header">Modificações e Alterações</h3>
        </div>
        <div class="col-md-8">
          <a href="images/struct.jpg"><img class="img-responsive" src="images/struct.jpg"></a><br>
          <a href="images/function.jpg"><img class="img-responsive" src="images/function.jpg"></a>
        </div>

        <div class="col-md-4">
          <p><strong>Modificações em Relação ao <a href = "t1.html" target= "_blank">Trabalho P1</a></strong></p>
          <p class="text-justify">O algoritmo foi construído com base no <a href = "t1.html" target= "_blank">Trabalho P1</a>, entretanto, entre as modificações, agora os processos podem ser
           podem ser tratados como suspeitos de falha. Portanto a primeiro modificação consiste em um novo evento chamado <i>SUSPECT</i> (Suspeito), além dos estados <i>TEST</i> (Teste), <i>FAULT</i> (Falha) e <i>RECOVERY</i> (Recuperação), sendo que este último foi mantido no algoritmo, mas não há possibilidade do processo sofrer um recuperação neste modelo.</p>
          <p class="text-justify">A execução do algoritmo ocorre pela chamada da função <strong>cisjAssinc</strong> e além dos arquivos anteriores - num de processos e tempo de simulação - este novo algoritmo espera receber também a probabilidade de falhas nos testes do processos, sendo um número entre 0 e 100, onde 0 significa que há 0% chances de um teste levantar uma falsa suspeita de falha de um processo e, portanto, 100 significa, sempre suspeitar uma falha. A cada teste um número entre 0 e 100 é escolhido aleatoriamente (na verdade de forma pseudoaleatória). Se o número escolhido for menor ou igual ao valor da probabilidade informada, o teste de um processo válido levantará falsa suspeita de falha.
            Quando um processo está OK e é levantada uma falsa suspeita, tal informação aparece na tela e um evento para o processo vítima é criado. Dessa forma. o evento serve para contar quantas rodadas e testes se passaram, até que o processo perceba que ele foi vítima de uma falsa suspeita e provoque um auto encerramento (processo sai do sistema e passa a ser efetivamente uma falha real).
            Por fim, um processo só vai detectar que foi vítima de uma falsa suspeita quando ele testar corretamente um processo válido e ao atualizar os estados dos processos com base nas informações do processo testado, ele verificar se o seu estado naquele processo está como falho. Então ele sai do sistema e se torna uma falha real.</p>
        </div>

      </div>
    </div><!-- /.container -->

    <div class="container">

      <hr>

      <footer>
        <div class="row">
          <div class="col-lg-12">
            <p>Copyright &copy; 2023</p>
          </div>
        </div>
      </footer>
      
    </div><!-- /.container -->

    <script src="js/jquery-1.10.2.js"></script>
    <script src="js/bootstrap.js"></script>
    <script src="js/my.js"></script>

  </body>

</html>
